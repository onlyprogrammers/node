{"version":3,"file":"rrdom.min.js","sources":["../../rrweb-snapshot/es/rrweb-snapshot.js","../src/style.ts","../src/document.ts","../src/diff.ts","../src/index.ts"],"sourcesContent":["var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    var host = n === null || n === void 0 ? void 0 : n.host;\r\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    var cssText = rule.cssText;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    var statement = ['@import', \"url(\".concat(JSON.stringify(rule.href), \")\")];\r\n    if (rule.layerName === '') {\r\n        statement.push(\"layer\");\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(\"layer(\".concat(rule.layerName, \")\"));\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(\"supports(\".concat(rule.supportsText, \")\"));\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        var rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules).map(stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    var importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    return validateStringifiedCssRule(importStringified || rule.cssText);\r\n}\r\nfunction validateStringifiedCssRule(cssStringified) {\r\n    if (cssStringified.includes(':')) {\r\n        var regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n        return cssStringified.replace(regex, '$1\\\\$2');\r\n    }\r\n    return cssStringified;\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nvar Mirror = (function () {\r\n    function Mirror() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    Mirror.prototype.getId = function (n) {\r\n        var _a;\r\n        if (!n)\r\n            return -1;\r\n        var id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\r\n        return id !== null && id !== void 0 ? id : -1;\r\n    };\r\n    Mirror.prototype.getNode = function (id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    };\r\n    Mirror.prototype.getIds = function () {\r\n        return Array.from(this.idNodeMap.keys());\r\n    };\r\n    Mirror.prototype.getMeta = function (n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    };\r\n    Mirror.prototype.removeNodeFromMap = function (n) {\r\n        var _this = this;\r\n        var id = this.getId(n);\r\n        this.idNodeMap[\"delete\"](id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach(function (childNode) {\r\n                return _this.removeNodeFromMap(childNode);\r\n            });\r\n        }\r\n    };\r\n    Mirror.prototype.has = function (id) {\r\n        return this.idNodeMap.has(id);\r\n    };\r\n    Mirror.prototype.hasNode = function (node) {\r\n        return this.nodeMetaMap.has(node);\r\n    };\r\n    Mirror.prototype.add = function (n, meta) {\r\n        var id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    };\r\n    Mirror.prototype.replace = function (id, n) {\r\n        var oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            var meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    };\r\n    Mirror.prototype.reset = function () {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    };\r\n    return Mirror;\r\n}());\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction maskInputValue(_a) {\r\n    var element = _a.element, maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;\r\n    var text = value || '';\r\n    var actualType = type && toLowerCase(type);\r\n    if (maskInputOptions[tagName.toLowerCase()] ||\r\n        (actualType && maskInputOptions[actualType])) {\r\n        if (maskInputFn) {\r\n            text = maskInputFn(text, element);\r\n        }\r\n        else {\r\n            text = '*'.repeat(text.length);\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nvar ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    var ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    var chunkSize = 50;\r\n    for (var x = 0; x < canvas.width; x += chunkSize) {\r\n        for (var y = 0; y < canvas.height; y += chunkSize) {\r\n            var getImageData = ctx.getImageData;\r\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            var pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some(function (pixel) { return pixel !== 0; }))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    var type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\n\nvar _id = 1;\r\nvar tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nvar IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    var processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    var origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nvar canvasService;\r\nvar canvasCtx;\r\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nvar URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nvar URL_WWW_MATCH = /^www\\..*/i;\r\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {\r\n        var filePath = path1 || path2 || path3;\r\n        var maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return \"url(\".concat(maybeQuote).concat(filePath).concat(maybeQuote, \")\");\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return \"url(\".concat(maybeQuote).concat(filePath).concat(maybeQuote, \")\");\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return \"url(\".concat(maybeQuote).concat(extractOrigin(href) + filePath).concat(maybeQuote, \")\");\r\n        }\r\n        var stack = href.split('/');\r\n        var parts = filePath.split('/');\r\n        stack.pop();\r\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n            var part = parts_1[_i];\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return \"url(\".concat(maybeQuote).concat(stack.join('/')).concat(maybeQuote, \")\");\r\n    });\r\n}\r\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    var pos = 0;\r\n    function collectCharacters(regEx) {\r\n        var chars;\r\n        var match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    var output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        var url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            var descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            var inParens = false;\r\n            while (true) {\r\n                var c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    var a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    var a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector) {\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (var eIndex = element.classList.length; eIndex--;) {\r\n                var className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (node.nodeType !== node.ELEMENT_NODE) {\r\n        if (!checkAncestors)\r\n            return false;\r\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n    }\r\n    for (var eIndex = node.classList.length; eIndex--;) {\r\n        var className = node.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!checkAncestors)\r\n        return false;\r\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector) {\r\n    try {\r\n        var el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (typeof maskTextClass === 'string') {\r\n            if (el.classList.contains(maskTextClass))\r\n                return true;\r\n            if (el.closest(\".\".concat(maskTextClass)))\r\n                return true;\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, maskTextClass, true))\r\n                return true;\r\n        }\r\n        if (maskTextSelector) {\r\n            if (el.matches(maskTextSelector))\r\n                return true;\r\n            if (el.closest(maskTextSelector))\r\n                return true;\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    var win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    var fired = false;\r\n    var readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        var timer_1 = setTimeout(function () {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', function () {\r\n            clearTimeout(timer_1);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    var blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    var fired = false;\r\n    var styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    var timer = setTimeout(function () {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', function () {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    var doc = options.doc, mirror = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _a = options.maskInputOptions, maskInputOptions = _a === void 0 ? {} : _a, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _b = options.dataURLOptions, dataURLOptions = _b === void 0 ? {} : _b, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _c = options.newlyAddedElement, newlyAddedElement = _c === void 0 ? false : _c;\r\n    var rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: []\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId: rootId\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc: doc,\r\n                blockClass: blockClass,\r\n                blockSelector: blockSelector,\r\n                inlineStylesheet: inlineStylesheet,\r\n                maskInputOptions: maskInputOptions,\r\n                maskInputFn: maskInputFn,\r\n                dataURLOptions: dataURLOptions,\r\n                inlineImages: inlineImages,\r\n                recordCanvas: recordCanvas,\r\n                keepIframeSrcFn: keepIframeSrcFn,\r\n                newlyAddedElement: newlyAddedElement,\r\n                rootId: rootId\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                maskTextClass: maskTextClass,\r\n                maskTextSelector: maskTextSelector,\r\n                maskTextFn: maskTextFn,\r\n                rootId: rootId\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId: rootId\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId: rootId\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    var docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    var _a;\r\n    var maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, maskTextFn = options.maskTextFn, rootId = options.rootId;\r\n    var parentTagName = n.parentNode && n.parentNode.tagName;\r\n    var textContent = n.textContent;\r\n    var isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    var isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(\"Cannot get CSS styles from text's parentNode. Error: \".concat(err), n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    if (!isStyle &&\r\n        !isScript &&\r\n        textContent &&\r\n        needMaskingText(n, maskTextClass, maskTextSelector)) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle: isStyle,\r\n        rootId: rootId\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, inlineStylesheet = options.inlineStylesheet, _a = options.maskInputOptions, maskInputOptions = _a === void 0 ? {} : _a, maskInputFn = options.maskInputFn, _b = options.dataURLOptions, dataURLOptions = _b === void 0 ? {} : _b, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _c = options.newlyAddedElement, newlyAddedElement = _c === void 0 ? false : _c, rootId = options.rootId;\r\n    var needBlock = _isBlockedElement(n, blockClass, blockSelector);\r\n    var tagName = getValidTagName(n);\r\n    var attributes = {};\r\n    var len = n.attributes.length;\r\n    for (var i = 0; i < len; i++) {\r\n        var attr = n.attributes[i];\r\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        var stylesheet = Array.from(doc.styleSheets).find(function (s) {\r\n            return s.href === n.href;\r\n        });\r\n        var cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        var cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\r\n        var value = n.value;\r\n        var checked = n.checked;\r\n        if (attributes.type !== 'radio' &&\r\n            attributes.type !== 'checkbox' &&\r\n            attributes.type !== 'submit' &&\r\n            attributes.type !== 'button' &&\r\n            value) {\r\n            var type = getInputType(n);\r\n            attributes.value = maskInputValue({\r\n                element: n,\r\n                type: type,\r\n                tagName: tagName,\r\n                value: value,\r\n                maskInputOptions: maskInputOptions,\r\n                maskInputFn: maskInputFn\r\n            });\r\n        }\r\n        else if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            var canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            var blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        var image_1 = n;\r\n        var oldValue_1 = image_1.crossOrigin;\r\n        image_1.crossOrigin = 'anonymous';\r\n        var recordInlineImage_1 = function () {\r\n            image_1.removeEventListener('load', recordInlineImage_1);\r\n            try {\r\n                canvasService.width = image_1.naturalWidth;\r\n                canvasService.height = image_1.naturalHeight;\r\n                canvasCtx.drawImage(image_1, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(\"Cannot inline img src=\".concat(image_1.currentSrc, \"! Error: \").concat(err));\r\n            }\r\n            oldValue_1\r\n                ? (attributes.crossOrigin = oldValue_1)\r\n                : image_1.removeAttribute('crossorigin');\r\n        };\r\n        if (image_1.complete && image_1.naturalWidth !== 0)\r\n            recordInlineImage_1();\r\n        else\r\n            image_1.addEventListener('load', recordInlineImage_1);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        attributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        attributes.rr_mediaCurrentTime = n.currentTime;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        var _d = n.getBoundingClientRect(), width = _d.width, height = _d.height;\r\n        attributes = {\r\n            \"class\": attributes[\"class\"],\r\n            rr_width: \"\".concat(width, \"px\"),\r\n            rr_height: \"\".concat(height, \"px\")\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName: tagName,\r\n        attributes: attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock: needBlock,\r\n        rootId: rootId\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    sn.attributes.href.endsWith('.js')))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    var doc = options.doc, mirror = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, onStylesheetLoad = options.onStylesheetLoad, _h = options.stylesheetLoadTimeout, stylesheetLoadTimeout = _h === void 0 ? 5000 : _h, _j = options.keepIframeSrcFn, keepIframeSrcFn = _j === void 0 ? function () { return false; } : _j, _k = options.newlyAddedElement, newlyAddedElement = _k === void 0 ? false : _k;\r\n    var _l = options.preserveWhiteSpace, preserveWhiteSpace = _l === void 0 ? true : _l;\r\n    var _serializedNode = serializeNode(n, {\r\n        doc: doc,\r\n        mirror: mirror,\r\n        blockClass: blockClass,\r\n        blockSelector: blockSelector,\r\n        maskTextClass: maskTextClass,\r\n        maskTextSelector: maskTextSelector,\r\n        inlineStylesheet: inlineStylesheet,\r\n        maskInputOptions: maskInputOptions,\r\n        maskTextFn: maskTextFn,\r\n        maskInputFn: maskInputFn,\r\n        dataURLOptions: dataURLOptions,\r\n        inlineImages: inlineImages,\r\n        recordCanvas: recordCanvas,\r\n        keepIframeSrcFn: keepIframeSrcFn,\r\n        newlyAddedElement: newlyAddedElement\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    var id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    var serializedNode = Object.assign(_serializedNode, { id: id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    var recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        var shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        var bypassOptions = {\r\n            doc: doc,\r\n            mirror: mirror,\r\n            blockClass: blockClass,\r\n            blockSelector: blockSelector,\r\n            maskTextClass: maskTextClass,\r\n            maskTextSelector: maskTextSelector,\r\n            skipChild: skipChild,\r\n            inlineStylesheet: inlineStylesheet,\r\n            maskInputOptions: maskInputOptions,\r\n            maskTextFn: maskTextFn,\r\n            maskInputFn: maskInputFn,\r\n            slimDOMOptions: slimDOMOptions,\r\n            dataURLOptions: dataURLOptions,\r\n            inlineImages: inlineImages,\r\n            recordCanvas: recordCanvas,\r\n            preserveWhiteSpace: preserveWhiteSpace,\r\n            onSerialize: onSerialize,\r\n            onIframeLoad: onIframeLoad,\r\n            iframeLoadTimeout: iframeLoadTimeout,\r\n            onStylesheetLoad: onStylesheetLoad,\r\n            stylesheetLoadTimeout: stylesheetLoadTimeout,\r\n            keepIframeSrcFn: keepIframeSrcFn\r\n        };\r\n        for (var _i = 0, _m = Array.from(n.childNodes); _i < _m.length; _i++) {\r\n            var childN = _m[_i];\r\n            var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n            if (serializedChildNode) {\r\n                serializedNode.childNodes.push(serializedChildNode);\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (var _o = 0, _p = Array.from(n.shadowRoot.childNodes); _o < _p.length; _o++) {\r\n                var childN = _p[_o];\r\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, function () {\r\n            var iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror: mirror,\r\n                    blockClass: blockClass,\r\n                    blockSelector: blockSelector,\r\n                    maskTextClass: maskTextClass,\r\n                    maskTextSelector: maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet: inlineStylesheet,\r\n                    maskInputOptions: maskInputOptions,\r\n                    maskTextFn: maskTextFn,\r\n                    maskInputFn: maskInputFn,\r\n                    slimDOMOptions: slimDOMOptions,\r\n                    dataURLOptions: dataURLOptions,\r\n                    inlineImages: inlineImages,\r\n                    recordCanvas: recordCanvas,\r\n                    preserveWhiteSpace: preserveWhiteSpace,\r\n                    onSerialize: onSerialize,\r\n                    onIframeLoad: onIframeLoad,\r\n                    iframeLoadTimeout: iframeLoadTimeout,\r\n                    onStylesheetLoad: onStylesheetLoad,\r\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\r\n                    keepIframeSrcFn: keepIframeSrcFn\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        serializedNode.attributes.rel === 'stylesheet') {\r\n        onceStylesheetLoaded(n, function () {\r\n            if (onStylesheetLoad) {\r\n                var serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc: doc,\r\n                    mirror: mirror,\r\n                    blockClass: blockClass,\r\n                    blockSelector: blockSelector,\r\n                    maskTextClass: maskTextClass,\r\n                    maskTextSelector: maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet: inlineStylesheet,\r\n                    maskInputOptions: maskInputOptions,\r\n                    maskTextFn: maskTextFn,\r\n                    maskInputFn: maskInputFn,\r\n                    slimDOMOptions: slimDOMOptions,\r\n                    dataURLOptions: dataURLOptions,\r\n                    inlineImages: inlineImages,\r\n                    recordCanvas: recordCanvas,\r\n                    preserveWhiteSpace: preserveWhiteSpace,\r\n                    onSerialize: onSerialize,\r\n                    onIframeLoad: onIframeLoad,\r\n                    iframeLoadTimeout: iframeLoadTimeout,\r\n                    onStylesheetLoad: onStylesheetLoad,\r\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\r\n                    keepIframeSrcFn: keepIframeSrcFn\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    var _a = options || {}, _b = _a.mirror, mirror = _b === void 0 ? new Mirror() : _b, _c = _a.blockClass, blockClass = _c === void 0 ? 'rr-block' : _c, _d = _a.blockSelector, blockSelector = _d === void 0 ? null : _d, _e = _a.maskTextClass, maskTextClass = _e === void 0 ? 'rr-mask' : _e, _f = _a.maskTextSelector, maskTextSelector = _f === void 0 ? null : _f, _g = _a.inlineStylesheet, inlineStylesheet = _g === void 0 ? true : _g, _h = _a.inlineImages, inlineImages = _h === void 0 ? false : _h, _j = _a.recordCanvas, recordCanvas = _j === void 0 ? false : _j, _k = _a.maskAllInputs, maskAllInputs = _k === void 0 ? false : _k, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _l = _a.slimDOM, slimDOM = _l === void 0 ? false : _l, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, onStylesheetLoad = _a.onStylesheetLoad, stylesheetLoadTimeout = _a.stylesheetLoadTimeout, _m = _a.keepIframeSrcFn, keepIframeSrcFn = _m === void 0 ? function () { return false; } : _m;\r\n    var maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true\r\n        }\r\n        : maskAllInputs === false\r\n            ? {\r\n                password: true\r\n            }\r\n            : maskAllInputs;\r\n    var slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror: mirror,\r\n        blockClass: blockClass,\r\n        blockSelector: blockSelector,\r\n        maskTextClass: maskTextClass,\r\n        maskTextSelector: maskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet: inlineStylesheet,\r\n        maskInputOptions: maskInputOptions,\r\n        maskTextFn: maskTextFn,\r\n        maskInputFn: maskInputFn,\r\n        slimDOMOptions: slimDOMOptions,\r\n        dataURLOptions: dataURLOptions,\r\n        inlineImages: inlineImages,\r\n        recordCanvas: recordCanvas,\r\n        preserveWhiteSpace: preserveWhiteSpace,\r\n        onSerialize: onSerialize,\r\n        onIframeLoad: onIframeLoad,\r\n        iframeLoadTimeout: iframeLoadTimeout,\r\n        onStylesheetLoad: onStylesheetLoad,\r\n        stylesheetLoadTimeout: stylesheetLoadTimeout,\r\n        keepIframeSrcFn: keepIframeSrcFn,\r\n        newlyAddedElement: false\r\n    });\r\n}\r\nfunction visitSnapshot(node, onVisit) {\r\n    function walk(current) {\r\n        onVisit(current);\r\n        if (current.type === NodeType.Document ||\r\n            current.type === NodeType.Element) {\r\n            current.childNodes.forEach(walk);\r\n        }\r\n    }\r\n    walk(node);\r\n}\r\nfunction cleanupSnapshot() {\r\n    _id = 1;\r\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var lineno = 1;\r\n    var column = 1;\r\n    function updatePosition(str) {\r\n        var lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        var i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        var start = { line: lineno, column: column };\r\n        return function (node) {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    var Position = (function () {\r\n        function Position(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column: column };\r\n            this.source = options.source;\r\n        }\r\n        return Position;\r\n    }());\r\n    Position.prototype.content = css;\r\n    var errorsList = [];\r\n    function error(msg) {\r\n        var err = new Error(\"\".concat(options.source || '', \":\").concat(lineno, \":\").concat(column, \": \").concat(msg));\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        var rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList\r\n            }\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        var node;\r\n        var rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        var m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules) {\r\n        if (rules === void 0) { rules = []; }\r\n        var c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        var pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        var i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        var str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str\r\n        });\r\n    }\r\n    function selector() {\r\n        var m = match(/^([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return trim(m[0])\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\r\n            return m.replace(/,/g, '\\u200C');\r\n        })\r\n            .split(/\\s*(?![^(]*\\)),\\s*/)\r\n            .map(function (s) {\r\n            return s.replace(/\\u200C/g, ',');\r\n        });\r\n    }\r\n    function declaration() {\r\n        var pos = position();\r\n        var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        var prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(\"property missing ':'\");\r\n        }\r\n        var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        var ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : ''\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        var decls = [];\r\n        if (!open()) {\r\n            return error(\"missing '{'\");\r\n        }\r\n        comments(decls);\r\n        var decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(\"missing '}'\");\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        var m;\r\n        var vals = [];\r\n        var pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations()\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        var pos = position();\r\n        var m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        var name = m[1];\r\n        if (!open()) {\r\n            return error(\"@keyframes missing '{'\");\r\n        }\r\n        var frame;\r\n        var frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(\"@keyframes missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name: name,\r\n            vendor: vendor,\r\n            keyframes: frames\r\n        });\r\n    }\r\n    function atsupports() {\r\n        var pos = position();\r\n        var m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(\"@supports missing '{'\");\r\n        }\r\n        var style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(\"@supports missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports: supports,\r\n            rules: style\r\n        });\r\n    }\r\n    function athost() {\r\n        var pos = position();\r\n        var m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(\"@host missing '{'\");\r\n        }\r\n        var style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(\"@host missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style\r\n        });\r\n    }\r\n    function atmedia() {\r\n        var pos = position();\r\n        var m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(\"@media missing '{'\");\r\n        }\r\n        var style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(\"@media missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media: media,\r\n            rules: style\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        var pos = position();\r\n        var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2])\r\n        });\r\n    }\r\n    function atpage() {\r\n        var pos = position();\r\n        var m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var sel = selector() || [];\r\n        if (!open()) {\r\n            return error(\"@page missing '{'\");\r\n        }\r\n        var decls = comments();\r\n        var decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(\"@page missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls\r\n        });\r\n    }\r\n    function atdocument() {\r\n        var pos = position();\r\n        var m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        var vendor = trim(m[1]);\r\n        var doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(\"@document missing '{'\");\r\n        }\r\n        var style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(\"@document missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor: vendor,\r\n            rules: style\r\n        });\r\n    }\r\n    function atfontface() {\r\n        var pos = position();\r\n        var m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(\"@font-face missing '{'\");\r\n        }\r\n        var decls = comments();\r\n        var decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(\"@font-face missing '}'\");\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls\r\n        });\r\n    }\r\n    var atimport = _compileAtrule('import');\r\n    var atcharset = _compileAtrule('charset');\r\n    var atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\r\n        return function () {\r\n            var pos = position();\r\n            var m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            var ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        var pos = position();\r\n        var sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations()\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    var isNode = obj && typeof obj.type === 'string';\r\n    var childParent = isNode ? obj : parent;\r\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\r\n        var k = _a[_i];\r\n        var value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach(function (v) {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nvar tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient'\r\n};\r\nfunction getTagName(n) {\r\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nvar HOVER_SELECTOR = /([^\\\\]):hover/;\r\nvar HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction addHoverClass(cssText, cache) {\r\n    var cachedStyle = cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    var ast = parse(cssText, {\r\n        silent: true\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    var selectors = [];\r\n    ast.stylesheet.rules.forEach(function (rule) {\r\n        if ('selectors' in rule) {\r\n            (rule.selectors || []).forEach(function (selector) {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    if (selectors.length === 0) {\r\n        return cssText;\r\n    }\r\n    var selectorMatcher = new RegExp(selectors\r\n        .filter(function (selector, index) { return selectors.indexOf(selector) === index; })\r\n        .sort(function (a, b) { return b.length - a.length; })\r\n        .map(function (selector) {\r\n        return escapeRegExp(selector);\r\n    })\r\n        .join('|'), 'g');\r\n    var result = cssText.replace(selectorMatcher, function (selector) {\r\n        var newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n        return \"\".concat(selector, \", \").concat(newSelector);\r\n    });\r\n    cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    var stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass: stylesWithHoverClass\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    var doc = options.doc, hackCss = options.hackCss, cache = options.cache;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            var tagName = getTagName(n);\r\n            var node_1;\r\n            if (n.isSVG) {\r\n                node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                node_1 = doc.createElement(tagName);\r\n            }\r\n            var specialAttributes = {};\r\n            for (var name_1 in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name_1)) {\r\n                    continue;\r\n                }\r\n                var value = n.attributes[name_1];\r\n                if (tagName === 'option' &&\r\n                    name_1 === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name_1.startsWith('rr_')) {\r\n                    specialAttributes[name_1] = value;\r\n                    continue;\r\n                }\r\n                var isTextarea = tagName === 'textarea' && name_1 === 'value';\r\n                var isRemoteOrDynamicCss = tagName === 'style' && name_1 === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = addHoverClass(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    var child = doc.createTextNode(value);\r\n                    for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\r\n                        var c = _a[_i];\r\n                        if (c.nodeType === node_1.TEXT_NODE) {\r\n                            node_1.removeChild(c);\r\n                        }\r\n                    }\r\n                    node_1.appendChild(child);\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name_1 === 'xlink:href') {\r\n                        node_1.setAttributeNS('http://www.w3.org/1999/xlink', name_1, value.toString());\r\n                    }\r\n                    else if (name_1 === 'onload' ||\r\n                        name_1 === 'onclick' ||\r\n                        name_1.substring(0, 7) === 'onmouse') {\r\n                        node_1.setAttribute('_' + name_1, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name_1 === 'content') {\r\n                        node_1.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload') &&\r\n                        n.attributes.as === 'script') {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        n.attributes.href.endsWith('.js')) {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node_1.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node_1.setAttribute(name_1, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            var _loop_1 = function (name_2) {\r\n                var value = specialAttributes[name_2];\r\n                if (tagName === 'canvas' && name_2 === 'rr_dataURL') {\r\n                    var image_1 = document.createElement('img');\r\n                    image_1.onload = function () {\r\n                        var ctx = node_1.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\r\n                        }\r\n                    };\r\n                    image_1.src = value.toString();\r\n                    if (node_1.RRNodeType)\r\n                        node_1.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name_2 === 'rr_dataURL') {\r\n                    var image = node_1;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name_2 === 'rr_width') {\r\n                    node_1.style.width = value.toString();\r\n                }\r\n                else if (name_2 === 'rr_height') {\r\n                    node_1.style.height = value.toString();\r\n                }\r\n                else if (name_2 === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node_1.currentTime = value;\r\n                }\r\n                else if (name_2 === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node_1\r\n                                .play()[\"catch\"](function (e) { return console.warn('media playback error', e); });\r\n                            break;\r\n                        case 'paused':\r\n                            node_1.pause();\r\n                            break;\r\n                    }\r\n                }\r\n            };\r\n            for (var name_2 in specialAttributes) {\r\n                _loop_1(name_2);\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node_1.shadowRoot) {\r\n                    node_1.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node_1.shadowRoot.firstChild) {\r\n                        node_1.shadowRoot.removeChild(node_1.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node_1;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? addHoverClass(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    var doc = options.doc, mirror = options.mirror, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.hackCss, hackCss = _b === void 0 ? true : _b, afterAppend = options.afterAppend, cache = options.cache;\r\n    if (mirror.has(n.id)) {\r\n        var nodeInMirror = mirror.getNode(n.id);\r\n        var meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    var node = buildNode(n, { doc: doc, hackCss: hackCss, cache: cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        var _loop_2 = function (childN) {\r\n            var childNode = buildNodeWithSN(childN, {\r\n                doc: doc,\r\n                mirror: mirror,\r\n                skipChild: false,\r\n                hackCss: hackCss,\r\n                afterAppend: afterAppend,\r\n                cache: cache\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                return \"continue\";\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                var htmlElement = childNode;\r\n                var body_1 = null;\r\n                htmlElement.childNodes.forEach(function (child) {\r\n                    if (child.nodeName === 'BODY')\r\n                        body_1 = child;\r\n                });\r\n                if (body_1) {\r\n                    htmlElement.removeChild(body_1);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body_1);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        };\r\n        for (var _i = 0, _c = n.childNodes; _i < _c.length; _i++) {\r\n            var childN = _c[_i];\r\n            _loop_2(childN);\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (var _i = 0, _a = mirror.getIds(); _i < _a.length; _i++) {\r\n        var id = _a[_i];\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    var n = mirror.getMeta(node);\r\n    if ((n === null || n === void 0 ? void 0 : n.type) !== NodeType.Element) {\r\n        return;\r\n    }\r\n    var el = node;\r\n    for (var name_3 in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name_3) &&\r\n            name_3.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        var value = n.attributes[name_3];\r\n        if (name_3 === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name_3 === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    var doc = options.doc, onVisit = options.onVisit, _a = options.hackCss, hackCss = _a === void 0 ? true : _a, afterAppend = options.afterAppend, cache = options.cache, _b = options.mirror, mirror = _b === void 0 ? new Mirror() : _b;\r\n    var node = buildNodeWithSN(n, {\r\n        doc: doc,\r\n        mirror: mirror,\r\n        skipChild: false,\r\n        hackCss: hackCss,\r\n        afterAppend: afterAppend,\r\n        cache: cache\r\n    });\r\n    visit(mirror, function (visitedNode) {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, addHoverClass, buildNodeWithSN, classMatchesRegex, cleanupSnapshot, createCache, createMirror, escapeImportStatement, genId, getInputType, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, transformAttribute, validateStringifiedCssRule, visitSnapshot };\n","export function parseCSSText(cssText: string): Record<string, string> {\n  const res: Record<string, string> = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  const comment = /\\/\\*.*?\\*\\//g;\n  cssText\n    .replace(comment, '')\n    .split(listDelimiter)\n    .forEach(function (item) {\n      if (item) {\n        const tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[camelize(tmp[0].trim())] = tmp[1].trim());\n      }\n    });\n  return res;\n}\n\nexport function toCSSText(style: Record<string, string>): string {\n  const properties = [];\n  for (const name in style) {\n    const value = style[name];\n    if (typeof value !== 'string') continue;\n    const normalizedName = hyphenate(name);\n    properties.push(`${normalizedName}: ${value};`);\n  }\n  return properties.join(' ');\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-([a-z])/g;\nconst CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;\nexport const camelize = (str: string): string => {\n  if (CUSTOM_PROPERTY_REGEX.test(str)) return str;\n  return str.replace(camelizeRE, (_, c: string) => (c ? c.toUpperCase() : ''));\n};\n\n/**\n * Hyphenate a camelCase string.\n */\nconst hyphenateRE = /\\B([A-Z])/g;\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n};\n","import { NodeType as RRNodeType } from 'rrweb-snapshot';\nimport { parseCSSText, camelize, toCSSText } from './style';\nexport interface IRRNode {\n  parentElement: IRRNode | null;\n  parentNode: IRRNode | null;\n  ownerDocument: IRRDocument;\n  readonly childNodes: IRRNode[];\n  readonly ELEMENT_NODE: number;\n  readonly TEXT_NODE: number;\n  // corresponding nodeType value of standard HTML Node\n  readonly nodeType: number;\n  readonly nodeName: string; // https://dom.spec.whatwg.org/#dom-node-nodename\n  readonly RRNodeType: RRNodeType;\n\n  firstChild: IRRNode | null;\n\n  lastChild: IRRNode | null;\n\n  previousSibling: IRRNode | null;\n\n  nextSibling: IRRNode | null;\n\n  // If the node is a document or a doctype, textContent returns null.\n  textContent: string | null;\n\n  contains(node: IRRNode): boolean;\n\n  appendChild(newChild: IRRNode): IRRNode;\n\n  insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode;\n\n  removeChild(node: IRRNode): IRRNode;\n\n  toString(): string;\n}\nexport interface IRRDocument extends IRRNode {\n  documentElement: IRRElement | null;\n\n  body: IRRElement | null;\n\n  head: IRRElement | null;\n\n  implementation: IRRDocument;\n\n  firstElementChild: IRRElement | null;\n\n  readonly nodeName: '#document';\n\n  compatMode: 'BackCompat' | 'CSS1Compat';\n\n  createDocument(\n    _namespace: string | null,\n    _qualifiedName: string | null,\n    _doctype?: DocumentType | null,\n  ): IRRDocument;\n\n  createDocumentType(\n    qualifiedName: string,\n    publicId: string,\n    systemId: string,\n  ): IRRDocumentType;\n\n  createElement(tagName: string): IRRElement;\n\n  createElementNS(_namespaceURI: string, qualifiedName: string): IRRElement;\n\n  createTextNode(data: string): IRRText;\n\n  createComment(data: string): IRRComment;\n\n  createCDATASection(data: string): IRRCDATASection;\n\n  open(): void;\n\n  close(): void;\n\n  write(content: string): void;\n}\nexport interface IRRElement extends IRRNode {\n  tagName: string;\n  attributes: Record<string, string>;\n  shadowRoot: IRRElement | null;\n  scrollLeft?: number;\n  scrollTop?: number;\n  id: string;\n  className: string;\n  classList: ClassList;\n  style: CSSStyleDeclaration;\n\n  attachShadow(init: ShadowRootInit): IRRElement;\n\n  getAttribute(name: string): string | null;\n\n  setAttribute(name: string, attribute: string): void;\n\n  setAttributeNS(\n    namespace: string | null,\n    qualifiedName: string,\n    value: string,\n  ): void;\n\n  removeAttribute(name: string): void;\n\n  dispatchEvent(event: Event): boolean;\n}\nexport interface IRRDocumentType extends IRRNode {\n  readonly name: string;\n  readonly publicId: string;\n  readonly systemId: string;\n}\nexport interface IRRText extends IRRNode {\n  readonly nodeName: '#text';\n  data: string;\n}\nexport interface IRRComment extends IRRNode {\n  readonly nodeName: '#comment';\n  data: string;\n}\nexport interface IRRCDATASection extends IRRNode {\n  readonly nodeName: '#cdata-section';\n  data: string;\n}\n\ntype ConstrainedConstructor<T = Record<string, unknown>> = new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => T;\n\n/**\n * This is designed as an abstract class so it should never be instantiated.\n */\nexport class BaseRRNode implements IRRNode {\n  public parentElement: IRRNode | null = null;\n  public parentNode: IRRNode | null = null;\n  public ownerDocument: IRRDocument;\n  public firstChild: IRRNode | null = null;\n  public lastChild: IRRNode | null = null;\n  public previousSibling: IRRNode | null = null;\n  public nextSibling: IRRNode | null = null;\n\n  public textContent: string | null;\n\n  public readonly ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\n  public readonly TEXT_NODE: number = NodeType.TEXT_NODE;\n  // corresponding nodeType value of standard HTML Node\n  public readonly nodeType: number;\n  public readonly nodeName: string;\n  public readonly RRNodeType: RRNodeType;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  constructor(..._args: any[]) {\n    //\n  }\n\n  public get childNodes(): IRRNode[] {\n    const childNodes: IRRNode[] = [];\n    let childIterator: IRRNode | null = this.firstChild;\n    while (childIterator) {\n      childNodes.push(childIterator);\n      childIterator = childIterator.nextSibling;\n    }\n    return childNodes;\n  }\n\n  public contains(node: IRRNode) {\n    if (!(node instanceof BaseRRNode)) return false;\n    else if (node.ownerDocument !== this.ownerDocument) return false;\n    else if (node === this) return true;\n\n    while (node.parentNode) {\n      if (node.parentNode === this) return true;\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public appendChild(_newChild: IRRNode): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public insertBefore(_newChild: IRRNode, _refChild: IRRNode | null): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public removeChild(_node: IRRNode): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  public toString(): string {\n    return 'RRNode';\n  }\n}\n\nexport function BaseRRDocumentImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  return class BaseRRDocument extends RRNodeClass implements IRRDocument {\n    public readonly nodeType: number = NodeType.DOCUMENT_NODE;\n    public readonly nodeName: '#document' = '#document';\n    public readonly compatMode: 'BackCompat' | 'CSS1Compat' = 'CSS1Compat';\n    public readonly RRNodeType = RRNodeType.Document;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(...args: any[]) {\n      super(args);\n      this.textContent = null;\n      this.ownerDocument = this;\n    }\n\n    public get documentElement(): IRRElement | null {\n      return (\n        (this.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'HTML',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get body(): IRRElement | null {\n      return (\n        (this.documentElement?.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'BODY',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get head(): IRRElement | null {\n      return (\n        (this.documentElement?.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'HEAD',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get implementation(): IRRDocument {\n      return this;\n    }\n\n    public get firstElementChild(): IRRElement | null {\n      return this.documentElement;\n    }\n\n    public appendChild(newChild: IRRNode): IRRNode {\n      const nodeType = newChild.RRNodeType;\n      if (\n        nodeType === RRNodeType.Element ||\n        nodeType === RRNodeType.DocumentType\n      ) {\n        if (this.childNodes.some((s) => s.RRNodeType === nodeType)) {\n          throw new Error(\n            `RRDomException: Failed to execute 'appendChild' on 'RRNode': Only one ${\n              nodeType === RRNodeType.Element ? 'RRElement' : 'RRDoctype'\n            } on RRDocument allowed.`,\n          );\n        }\n      }\n\n      const child = appendChild(this, newChild);\n      child.parentElement = null;\n      return child;\n    }\n\n    public insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode {\n      const nodeType = newChild.RRNodeType;\n      if (\n        nodeType === RRNodeType.Element ||\n        nodeType === RRNodeType.DocumentType\n      ) {\n        if (this.childNodes.some((s) => s.RRNodeType === nodeType)) {\n          throw new Error(\n            `RRDomException: Failed to execute 'insertBefore' on 'RRNode': Only one ${\n              nodeType === RRNodeType.Element ? 'RRElement' : 'RRDoctype'\n            } on RRDocument allowed.`,\n          );\n        }\n      }\n\n      const child = insertBefore(this, newChild, refChild);\n      child.parentElement = null;\n      return child;\n    }\n\n    public removeChild(node: IRRNode): IRRNode {\n      return removeChild(this, node);\n    }\n\n    public open() {\n      this.firstChild = null;\n      this.lastChild = null;\n    }\n\n    public close() {\n      //\n    }\n\n    /**\n     * Adhoc implementation for setting xhtml namespace in rebuilt.ts (rrweb-snapshot).\n     * There are two lines used this function:\n     * 1. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\"\\>')\n     * 2. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\"\\>')\n     */\n    public write(content: string) {\n      let publicId;\n      if (\n        content ===\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n      )\n        publicId = '-//W3C//DTD XHTML 1.0 Transitional//EN';\n      else if (\n        content ===\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n      )\n        publicId = '-//W3C//DTD HTML 4.0 Transitional//EN';\n      if (publicId) {\n        const doctype = this.createDocumentType('html', publicId, '');\n        this.open();\n        this.appendChild(doctype);\n      }\n    }\n\n    createDocument(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _namespace: string | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _qualifiedName: string | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _doctype?: DocumentType | null,\n    ): IRRDocument {\n      return new BaseRRDocument();\n    }\n\n    createDocumentType(\n      qualifiedName: string,\n      publicId: string,\n      systemId: string,\n    ): IRRDocumentType {\n      const doctype = new (BaseRRDocumentTypeImpl(BaseRRNode))(\n        qualifiedName,\n        publicId,\n        systemId,\n      );\n      doctype.ownerDocument = this;\n      return doctype;\n    }\n\n    createElement(tagName: string): IRRElement {\n      const element = new (BaseRRElementImpl(BaseRRNode))(tagName);\n      element.ownerDocument = this;\n      return element;\n    }\n\n    createElementNS(_namespaceURI: string, qualifiedName: string): IRRElement {\n      return this.createElement(qualifiedName);\n    }\n\n    createTextNode(data: string): IRRText {\n      const text = new (BaseRRTextImpl(BaseRRNode))(data);\n      text.ownerDocument = this;\n      return text;\n    }\n\n    createComment(data: string): IRRComment {\n      const comment = new (BaseRRCommentImpl(BaseRRNode))(data);\n      comment.ownerDocument = this;\n      return comment;\n    }\n\n    createCDATASection(data: string): IRRCDATASection {\n      const CDATASection = new (BaseRRCDATASectionImpl(BaseRRNode))(data);\n      CDATASection.ownerDocument = this;\n      return CDATASection;\n    }\n\n    toString() {\n      return 'RRDocument';\n    }\n  };\n}\n\nexport function BaseRRDocumentTypeImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRDocumentType\n    extends RRNodeClass\n    implements IRRDocumentType\n  {\n    public readonly nodeType: number = NodeType.DOCUMENT_TYPE_NODE;\n    public readonly RRNodeType = RRNodeType.DocumentType;\n    public readonly nodeName: string;\n    public readonly name: string;\n    public readonly publicId: string;\n    public readonly systemId: string;\n\n    constructor(qualifiedName: string, publicId: string, systemId: string) {\n      super();\n      this.name = qualifiedName;\n      this.publicId = publicId;\n      this.systemId = systemId;\n      this.nodeName = qualifiedName;\n      this.textContent = null;\n    }\n\n    toString() {\n      return 'RRDocumentType';\n    }\n  };\n}\n\nexport function BaseRRElementImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRElement extends RRNodeClass implements IRRElement {\n    public readonly nodeType: number = NodeType.ELEMENT_NODE;\n    public readonly RRNodeType = RRNodeType.Element;\n    public readonly nodeName: string;\n    public tagName: string;\n    public attributes: Record<string, string> = {};\n    public shadowRoot: IRRElement | null = null;\n    public scrollLeft?: number;\n    public scrollTop?: number;\n\n    constructor(tagName: string) {\n      super();\n      this.tagName = tagName.toUpperCase();\n      this.nodeName = tagName.toUpperCase();\n    }\n\n    public get textContent(): string {\n      let result = '';\n      this.childNodes.forEach((node) => (result += node.textContent));\n      return result;\n    }\n\n    public set textContent(textContent: string) {\n      this.firstChild = null;\n      this.lastChild = null;\n      this.appendChild(this.ownerDocument.createTextNode(textContent));\n    }\n\n    public get classList(): ClassList {\n      return new ClassList(\n        this.attributes.class as string | undefined,\n        (newClassName) => {\n          this.attributes.class = newClassName;\n        },\n      );\n    }\n\n    public get id() {\n      return this.attributes.id || '';\n    }\n\n    public get className() {\n      return this.attributes.class || '';\n    }\n\n    public get style() {\n      const style = (\n        this.attributes.style ? parseCSSText(this.attributes.style) : {}\n      ) as CSSStyleDeclaration;\n      const hyphenateRE = /\\B([A-Z])/g;\n      style.setProperty = (\n        name: string,\n        value: string | null,\n        priority?: string,\n      ) => {\n        if (hyphenateRE.test(name)) return;\n        const normalizedName = camelize(name);\n        if (!value) delete style[normalizedName];\n        else style[normalizedName] = value;\n        if (priority === 'important') style[normalizedName] += ' !important';\n        this.attributes.style = toCSSText(style);\n      };\n      style.removeProperty = (name: string) => {\n        if (hyphenateRE.test(name)) return '';\n        const normalizedName = camelize(name);\n        const value = style[normalizedName] || '';\n        delete style[normalizedName];\n        this.attributes.style = toCSSText(style);\n        return value;\n      };\n      return style;\n    }\n\n    public getAttribute(name: string) {\n      return this.attributes[name] || null;\n    }\n\n    public setAttribute(name: string, attribute: string) {\n      this.attributes[name] = attribute;\n    }\n\n    public setAttributeNS(\n      _namespace: string | null,\n      qualifiedName: string,\n      value: string,\n    ): void {\n      this.setAttribute(qualifiedName, value);\n    }\n\n    public removeAttribute(name: string) {\n      delete this.attributes[name];\n    }\n\n    public appendChild(newChild: IRRNode): IRRNode {\n      return appendChild(this, newChild);\n    }\n\n    public insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode {\n      return insertBefore(this, newChild, refChild);\n    }\n\n    public removeChild(node: IRRNode): IRRNode {\n      return removeChild(this, node);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public attachShadow(_init: ShadowRootInit): IRRElement {\n      const shadowRoot = this.ownerDocument.createElement('SHADOWROOT');\n      this.shadowRoot = shadowRoot;\n      return shadowRoot;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public dispatchEvent(_event: Event) {\n      return true;\n    }\n\n    toString() {\n      let attributeString = '';\n      for (const attribute in this.attributes) {\n        attributeString += `${attribute}=\"${this.attributes[attribute]}\" `;\n      }\n      return `${this.tagName} ${attributeString}`;\n    }\n  };\n}\n\nexport function BaseRRMediaElementImpl<\n  RRElement extends ConstrainedConstructor<IRRElement>,\n>(RRElementClass: RRElement) {\n  return class BaseRRMediaElement extends RRElementClass {\n    public currentTime?: number;\n    public volume?: number;\n    public paused?: boolean;\n    public muted?: boolean;\n    public playbackRate?: number;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    attachShadow(_init: ShadowRootInit): IRRElement {\n      throw new Error(\n        `RRDomException: Failed to execute 'attachShadow' on 'RRElement': This RRElement does not support attachShadow`,\n      );\n    }\n    public play() {\n      this.paused = false;\n    }\n    public pause() {\n      this.paused = true;\n    }\n  };\n}\n\nexport function BaseRRTextImpl<RRNode extends ConstrainedConstructor<IRRNode>>(\n  RRNodeClass: RRNode,\n) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRText extends RRNodeClass implements IRRText {\n    public readonly nodeType: number = NodeType.TEXT_NODE;\n    public readonly nodeName: '#text' = '#text';\n    public readonly RRNodeType = RRNodeType.Text;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRText text=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport function BaseRRCommentImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRComment extends RRNodeClass implements IRRComment {\n    public readonly nodeType: number = NodeType.COMMENT_NODE;\n    public readonly nodeName: '#comment' = '#comment';\n    public readonly RRNodeType = RRNodeType.Comment;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRComment text=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport function BaseRRCDATASectionImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRCDATASection\n    extends RRNodeClass\n    implements IRRCDATASection\n  {\n    public readonly nodeName: '#cdata-section' = '#cdata-section';\n    public readonly nodeType: number = NodeType.CDATA_SECTION_NODE;\n    public readonly RRNodeType = RRNodeType.CDATA;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRCDATASection data=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport class ClassList {\n  private onChange: ((newClassText: string) => void) | undefined;\n  classes: string[] = [];\n\n  constructor(\n    classText?: string,\n    onChange?: ((newClassText: string) => void) | undefined,\n  ) {\n    if (classText) {\n      const classes = classText.trim().split(/\\s+/);\n      this.classes.push(...classes);\n    }\n    this.onChange = onChange;\n  }\n\n  add = (...classNames: string[]) => {\n    for (const item of classNames) {\n      const className = String(item);\n      if (this.classes.indexOf(className) >= 0) continue;\n      this.classes.push(className);\n    }\n    this.onChange && this.onChange(this.classes.join(' '));\n  };\n\n  remove = (...classNames: string[]) => {\n    this.classes = this.classes.filter(\n      (item) => classNames.indexOf(item) === -1,\n    );\n    this.onChange && this.onChange(this.classes.join(' '));\n  };\n}\n\nexport type CSSStyleDeclaration = Record<string, string> & {\n  setProperty: (\n    name: string,\n    value: string | null,\n    priority?: string | null,\n  ) => void;\n  removeProperty: (name: string) => string;\n};\n\nfunction appendChild(parent: IRRNode, newChild: IRRNode) {\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n\n  if (parent.lastChild) {\n    parent.lastChild.nextSibling = newChild;\n    newChild.previousSibling = parent.lastChild;\n  } else {\n    parent.firstChild = newChild;\n    newChild.previousSibling = null;\n  }\n  parent.lastChild = newChild;\n  newChild.nextSibling = null;\n  newChild.parentNode = parent;\n  newChild.parentElement = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\n\nfunction insertBefore(\n  parent: IRRNode,\n  newChild: IRRNode,\n  refChild: IRRNode | null,\n) {\n  if (!refChild) return appendChild(parent, newChild);\n\n  if (refChild.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'insertBefore' on 'RRNode': The RRNode before which the new node is to be inserted is not a child of this RRNode.\",\n    );\n\n  if (newChild === refChild) return newChild;\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n\n  newChild.previousSibling = refChild.previousSibling;\n  refChild.previousSibling = newChild;\n  newChild.nextSibling = refChild;\n\n  if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;\n  else parent.firstChild = newChild;\n\n  newChild.parentElement = parent;\n  newChild.parentNode = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\n\nfunction removeChild(parent: IRRNode, child: IRRNode) {\n  if (child.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'removeChild' on 'RRNode': The RRNode to be removed is not a child of this RRNode.\",\n    );\n  if (child.previousSibling)\n    child.previousSibling.nextSibling = child.nextSibling;\n  else parent.firstChild = child.nextSibling;\n  if (child.nextSibling)\n    child.nextSibling.previousSibling = child.previousSibling;\n  else parent.lastChild = child.previousSibling;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  child.parentElement = null;\n  child.parentNode = null;\n  return child;\n}\n\n// Enumerate nodeType value of standard HTML Node.\nexport enum NodeType {\n  PLACEHOLDER, // This isn't a node type. Enum type value starts from zero but NodeType value starts from 1.\n  ELEMENT_NODE,\n  ATTRIBUTE_NODE,\n  TEXT_NODE,\n  CDATA_SECTION_NODE,\n  ENTITY_REFERENCE_NODE,\n  ENTITY_NODE,\n  PROCESSING_INSTRUCTION_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n}\n","import {\n  NodeType as RRNodeType,\n  Mirror as NodeMirror,\n  elementNode,\n} from 'rrweb-snapshot';\nimport type {\n  canvasMutationData,\n  canvasEventWithTime,\n  inputData,\n  scrollData,\n  styleDeclarationData,\n  styleSheetRuleData,\n} from '@rrweb/types';\nimport type {\n  IRRCDATASection,\n  IRRComment,\n  IRRDocumentType,\n  IRRElement,\n  IRRNode,\n  IRRText,\n} from './document';\nimport type {\n  RRCanvasElement,\n  RRElement,\n  RRIFrameElement,\n  RRMediaElement,\n  RRStyleElement,\n  RRDocument,\n  Mirror,\n} from '.';\n\nconst NAMESPACES: Record<string, string> = {\n  svg: 'http://www.w3.org/2000/svg',\n  'xlink:href': 'http://www.w3.org/1999/xlink',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n};\n\n// camel case svg element tag names\nconst SVGTagMap: Record<string, string> = {\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\n\nexport type ReplayerHandler = {\n  mirror: NodeMirror;\n  applyCanvas: (\n    canvasEvent: canvasEventWithTime,\n    canvasMutationData: canvasMutationData,\n    target: HTMLCanvasElement,\n  ) => void;\n  applyInput: (data: inputData) => void;\n  applyScroll: (data: scrollData, isSync: boolean) => void;\n  applyStyleSheetMutation: (\n    data: styleDeclarationData | styleSheetRuleData,\n    styleSheet: CSSStyleSheet,\n  ) => void;\n  // Similar to the `afterAppend` callback in the `rrweb-snapshot` package. It's a postorder traversal of the newly appended nodes.\n  afterAppend?(node: Node, id: number): void;\n};\n\n// A set contains newly appended nodes. It's used to make sure the afterAppend callback can iterate newly appended nodes in the same traversal order as that in the `rrweb-snapshot` package.\nlet createdNodeSet: WeakSet<Node> | null = null;\n\n/**\n * Make the old tree to have the same structure and properties as the new tree with the diff algorithm.\n * @param oldTree - The old tree to be modified.\n * @param newTree - The new tree which the old tree will be modified to.\n * @param replayer - A slimmed replayer instance including the mirror of the old tree.\n * @param rrnodeMirror - The mirror of the new tree.\n */\nexport function diff(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror = (newTree as RRDocument).mirror ||\n    (newTree.ownerDocument as RRDocument).mirror,\n) {\n  oldTree = diffBeforeUpdatingChildren(\n    oldTree,\n    newTree,\n    replayer,\n    rrnodeMirror,\n  );\n\n  diffChildren(oldTree, newTree, replayer, rrnodeMirror);\n\n  diffAfterUpdatingChildren(oldTree, newTree, replayer, rrnodeMirror);\n}\n\n/**\n * Do some preparation work before updating the children of the old tree.\n */\nfunction diffBeforeUpdatingChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror,\n) {\n  if (replayer.afterAppend && !createdNodeSet) {\n    createdNodeSet = new WeakSet();\n    setTimeout(() => {\n      createdNodeSet = null;\n    }, 0);\n  }\n  // If the Mirror data has some flaws, the diff function may throw errors. We check the node consistency here to make it robust.\n  if (!sameNodeType(oldTree, newTree)) {\n    const calibratedOldTree = createOrGetNode(\n      newTree,\n      replayer.mirror,\n      rrnodeMirror,\n    );\n    oldTree.parentNode?.replaceChild(calibratedOldTree, oldTree);\n    oldTree = calibratedOldTree;\n  }\n  switch (newTree.RRNodeType) {\n    case RRNodeType.Document: {\n      /**\n       * Special cases for updating the document node:\n       * Case 1: If the oldTree is the content document of an iframe element and its content (HTML, HEAD, and BODY) is automatically mounted by browsers, we need to remove them to avoid unexpected behaviors. e.g. Selector matches may be case insensitive.\n       * Case 2: The newTree has a different serialized Id (a different document object), we need to reopen it and update the nodeMirror.\n       */\n      if (!nodeMatching(oldTree, newTree, replayer.mirror, rrnodeMirror)) {\n        const newMeta = rrnodeMirror.getMeta(newTree);\n        if (newMeta) {\n          replayer.mirror.removeNodeFromMap(oldTree);\n          (oldTree as Document).close();\n          (oldTree as Document).open();\n          replayer.mirror.add(oldTree, newMeta);\n          createdNodeSet?.add(oldTree);\n        }\n      }\n      break;\n    }\n    case RRNodeType.Element: {\n      const oldElement = oldTree as HTMLElement;\n      const newRRElement = newTree as IRRElement;\n      switch (newRRElement.tagName) {\n        case 'IFRAME': {\n          const oldContentDocument = (oldTree as HTMLIFrameElement)\n            .contentDocument;\n          // If the iframe is cross-origin, the contentDocument will be null.\n          if (!oldContentDocument) break;\n          // IFrame element doesn't have child nodes, so here we update its content document separately.\n          diff(\n            oldContentDocument,\n            (newTree as RRIFrameElement).contentDocument,\n            replayer,\n            rrnodeMirror,\n          );\n          break;\n        }\n      }\n      if (newRRElement.shadowRoot) {\n        if (!oldElement.shadowRoot) oldElement.attachShadow({ mode: 'open' });\n        diffChildren(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          oldElement.shadowRoot!,\n          newRRElement.shadowRoot,\n          replayer,\n          rrnodeMirror,\n        );\n      }\n      break;\n    }\n  }\n  return oldTree;\n}\n\n/**\n * Finish the diff work after updating the children of the old tree.\n */\nfunction diffAfterUpdatingChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror,\n) {\n  switch (newTree.RRNodeType) {\n    case RRNodeType.Document: {\n      const scrollData = (newTree as RRDocument).scrollData;\n      scrollData && replayer.applyScroll(scrollData, true);\n      break;\n    }\n    case RRNodeType.Element: {\n      const oldElement = oldTree as HTMLElement;\n      const newRRElement = newTree as RRElement;\n      diffProps(oldElement, newRRElement, rrnodeMirror);\n      newRRElement.scrollData &&\n        replayer.applyScroll(newRRElement.scrollData, true);\n      /**\n       * Input data need to get applied after all children of this node are updated.\n       * Otherwise when we set a value for a select element whose options are empty, the value won't actually update.\n       */\n      newRRElement.inputData && replayer.applyInput(newRRElement.inputData);\n      switch (newRRElement.tagName) {\n        case 'AUDIO':\n        case 'VIDEO': {\n          const oldMediaElement = oldTree as HTMLMediaElement;\n          const newMediaRRElement = newRRElement as RRMediaElement;\n          if (newMediaRRElement.paused !== undefined)\n            newMediaRRElement.paused\n              ? void oldMediaElement.pause()\n              : void oldMediaElement.play();\n          if (newMediaRRElement.muted !== undefined)\n            oldMediaElement.muted = newMediaRRElement.muted;\n          if (newMediaRRElement.volume !== undefined)\n            oldMediaElement.volume = newMediaRRElement.volume;\n          if (newMediaRRElement.currentTime !== undefined)\n            oldMediaElement.currentTime = newMediaRRElement.currentTime;\n          if (newMediaRRElement.playbackRate !== undefined)\n            oldMediaElement.playbackRate = newMediaRRElement.playbackRate;\n          break;\n        }\n        case 'CANVAS': {\n          const rrCanvasElement = newTree as RRCanvasElement;\n          // This canvas element is created with initial data in an iframe element. https://github.com/rrweb-io/rrweb/pull/944\n          if (rrCanvasElement.rr_dataURL !== null) {\n            const image = document.createElement('img');\n            image.onload = () => {\n              const ctx = (oldElement as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n            image.src = rrCanvasElement.rr_dataURL;\n          }\n          rrCanvasElement.canvasMutations.forEach((canvasMutation) =>\n            replayer.applyCanvas(\n              canvasMutation.event,\n              canvasMutation.mutation,\n              oldTree as HTMLCanvasElement,\n            ),\n          );\n          break;\n        }\n        // Props of style elements have to be updated after all children are updated. Otherwise the props can be overwritten by textContent.\n        case 'STYLE': {\n          const styleSheet = (oldElement as HTMLStyleElement).sheet;\n          styleSheet &&\n            (newTree as RRStyleElement).rules.forEach((data) =>\n              replayer.applyStyleSheetMutation(data, styleSheet),\n            );\n          break;\n        }\n      }\n      break;\n    }\n    case RRNodeType.Text:\n    case RRNodeType.Comment:\n    case RRNodeType.CDATA: {\n      if (\n        oldTree.textContent !==\n        (newTree as IRRText | IRRComment | IRRCDATASection).data\n      )\n        oldTree.textContent = (\n          newTree as IRRText | IRRComment | IRRCDATASection\n        ).data;\n      break;\n    }\n  }\n  if (createdNodeSet?.has(oldTree)) {\n    createdNodeSet.delete(oldTree);\n    replayer.afterAppend?.(oldTree, replayer.mirror.getId(oldTree));\n  }\n}\n\nfunction diffProps(\n  oldTree: HTMLElement,\n  newTree: IRRElement,\n  rrnodeMirror: Mirror,\n) {\n  const oldAttributes = oldTree.attributes;\n  const newAttributes = newTree.attributes;\n\n  for (const name in newAttributes) {\n    const newValue = newAttributes[name];\n    const sn = rrnodeMirror.getMeta(newTree) as elementNode | null;\n    if (sn?.isSVG && NAMESPACES[name])\n      oldTree.setAttributeNS(NAMESPACES[name], name, newValue);\n    else if (newTree.tagName === 'CANVAS' && name === 'rr_dataURL') {\n      const image = document.createElement('img');\n      image.src = newValue;\n      image.onload = () => {\n        const ctx = (oldTree as HTMLCanvasElement).getContext('2d');\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n        }\n      };\n    } else if (newTree.tagName === 'IFRAME' && name === 'srcdoc') continue;\n    else oldTree.setAttribute(name, newValue);\n  }\n\n  for (const { name } of Array.from(oldAttributes))\n    if (!(name in newAttributes)) oldTree.removeAttribute(name);\n\n  newTree.scrollLeft && (oldTree.scrollLeft = newTree.scrollLeft);\n  newTree.scrollTop && (oldTree.scrollTop = newTree.scrollTop);\n}\n\nfunction diffChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror,\n) {\n  const oldChildren: (Node | undefined)[] = Array.from(oldTree.childNodes);\n  const newChildren = newTree.childNodes;\n  if (oldChildren.length === 0 && newChildren.length === 0) return;\n  let oldStartIndex = 0,\n    oldEndIndex = oldChildren.length - 1,\n    newStartIndex = 0,\n    newEndIndex = newChildren.length - 1;\n  let oldStartNode = oldChildren[oldStartIndex],\n    oldEndNode = oldChildren[oldEndIndex],\n    newStartNode = newChildren[newStartIndex],\n    newEndNode = newChildren[newEndIndex];\n  let oldIdToIndex: Record<number, number> | undefined = undefined,\n    indexInOld: number | undefined = undefined;\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (oldStartNode === undefined) {\n      oldStartNode = oldChildren[++oldStartIndex];\n    } else if (oldEndNode === undefined) {\n      oldEndNode = oldChildren[--oldEndIndex];\n    } else if (\n      // same first node?\n      nodeMatching(oldStartNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldStartNode = oldChildren[++oldStartIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else if (\n      // same last node?\n      nodeMatching(oldEndNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldEndNode = oldChildren[--oldEndIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the first old node the same as the last new node?\n      nodeMatching(oldStartNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        oldTree.insertBefore(oldStartNode, oldEndNode.nextSibling);\n      } catch (e) {\n        console.warn(e);\n      }\n      oldStartNode = oldChildren[++oldStartIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the last old node the same as the first new node?\n      nodeMatching(oldEndNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        oldTree.insertBefore(oldEndNode, oldStartNode);\n      } catch (e) {\n        console.warn(e);\n      }\n      oldEndNode = oldChildren[--oldEndIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else {\n      // none of the elements matched\n\n      if (!oldIdToIndex) {\n        oldIdToIndex = {};\n        for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n          const oldChild = oldChildren[i];\n          if (oldChild && replayer.mirror.hasNode(oldChild))\n            oldIdToIndex[replayer.mirror.getId(oldChild)] = i;\n        }\n      }\n      indexInOld = oldIdToIndex[rrnodeMirror.getId(newStartNode)];\n      const nodeToMove = oldChildren[indexInOld];\n      if (\n        indexInOld !== undefined &&\n        nodeToMove &&\n        nodeMatching(nodeToMove, newStartNode, replayer.mirror, rrnodeMirror)\n      ) {\n        try {\n          oldTree.insertBefore(nodeToMove, oldStartNode);\n        } catch (e) {\n          console.warn(e);\n        }\n        oldChildren[indexInOld] = undefined;\n      } else {\n        const newNode = createOrGetNode(\n          newStartNode,\n          replayer.mirror,\n          rrnodeMirror,\n        );\n\n        if (\n          oldTree.nodeName === '#document' &&\n          oldStartNode &&\n          /**\n           * Special case 1: one document isn't allowed to have two doctype nodes at the same time, so we need to remove the old one first before inserting the new one.\n           * How this case happens: A parent document in the old tree already has a doctype node with an id e.g. #1. A new full snapshot rebuilds the replayer with a new doctype node with another id #2. According to the algorithm, the new doctype node will be inserted before the old one, which is not allowed by the Document standard.\n           */\n          ((newNode.nodeType === newNode.DOCUMENT_TYPE_NODE &&\n            oldStartNode.nodeType === oldStartNode.DOCUMENT_TYPE_NODE) ||\n            /**\n             * Special case 2: one document isn't allowed to have two HTMLElements at the same time, so we need to remove the old one first before inserting the new one.\n             * How this case happens: A mounted iframe element has an automatically created HTML element. We should delete it before inserting a serialized one. Otherwise, an error 'Only one element on document allowed' will be thrown.\n             */\n            (newNode.nodeType === newNode.ELEMENT_NODE &&\n              oldStartNode.nodeType === oldStartNode.ELEMENT_NODE))\n        ) {\n          oldTree.removeChild(oldStartNode);\n          replayer.mirror.removeNodeFromMap(oldStartNode);\n          oldStartNode = oldChildren[++oldStartIndex];\n        }\n\n        try {\n          oldTree.insertBefore(newNode, oldStartNode || null);\n        } catch (e) {\n          console.warn(e);\n        }\n      }\n      newStartNode = newChildren[++newStartIndex];\n    }\n  }\n  if (oldStartIndex > oldEndIndex) {\n    const referenceRRNode = newChildren[newEndIndex + 1];\n    let referenceNode: Node | null = null;\n    if (referenceRRNode)\n      referenceNode = replayer.mirror.getNode(\n        rrnodeMirror.getId(referenceRRNode),\n      );\n    for (; newStartIndex <= newEndIndex; ++newStartIndex) {\n      const newNode = createOrGetNode(\n        newChildren[newStartIndex],\n        replayer.mirror,\n        rrnodeMirror,\n      );\n      try {\n        oldTree.insertBefore(newNode, referenceNode);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n  } else if (newStartIndex > newEndIndex) {\n    for (; oldStartIndex <= oldEndIndex; oldStartIndex++) {\n      const node = oldChildren[oldStartIndex];\n      if (!node || node.parentNode !== oldTree) continue;\n      try {\n        oldTree.removeChild(node);\n        replayer.mirror.removeNodeFromMap(node);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n  }\n\n  // Recursively diff the children of the old tree and the new tree with their props and deeper structures.\n  let oldChild = oldTree.firstChild;\n  let newChild = newTree.firstChild;\n  while (oldChild !== null && newChild !== null) {\n    diff(oldChild, newChild, replayer, rrnodeMirror);\n    oldChild = oldChild.nextSibling;\n    newChild = newChild.nextSibling;\n  }\n}\n\nexport function createOrGetNode(\n  rrNode: IRRNode,\n  domMirror: NodeMirror,\n  rrnodeMirror: Mirror,\n): Node {\n  const nodeId = rrnodeMirror.getId(rrNode);\n  const sn = rrnodeMirror.getMeta(rrNode);\n  let node: Node | null = null;\n  // negative ids shouldn't be compared accross mirrors\n  if (nodeId > -1) node = domMirror.getNode(nodeId);\n  if (node !== null && sameNodeType(node, rrNode)) return node;\n  switch (rrNode.RRNodeType) {\n    case RRNodeType.Document:\n      node = new Document();\n      break;\n    case RRNodeType.DocumentType:\n      node = document.implementation.createDocumentType(\n        (rrNode as IRRDocumentType).name,\n        (rrNode as IRRDocumentType).publicId,\n        (rrNode as IRRDocumentType).systemId,\n      );\n      break;\n    case RRNodeType.Element: {\n      let tagName = (rrNode as IRRElement).tagName.toLowerCase();\n      tagName = SVGTagMap[tagName] || tagName;\n      if (sn && 'isSVG' in sn && sn?.isSVG) {\n        node = document.createElementNS(NAMESPACES['svg'], tagName);\n      } else node = document.createElement((rrNode as IRRElement).tagName);\n      break;\n    }\n    case RRNodeType.Text:\n      node = document.createTextNode((rrNode as IRRText).data);\n      break;\n    case RRNodeType.Comment:\n      node = document.createComment((rrNode as IRRComment).data);\n      break;\n    case RRNodeType.CDATA:\n      node = document.createCDATASection((rrNode as IRRCDATASection).data);\n      break;\n  }\n\n  if (sn) domMirror.add(node, { ...sn });\n  try {\n    createdNodeSet?.add(node);\n  } catch (e) {\n    // Just for safety concern.\n  }\n  return node;\n}\n\n/**\n * To check whether two nodes are the same type of node. If they are both Elements, check wether their tagNames are same or not.\n */\nexport function sameNodeType(node1: Node, node2: IRRNode) {\n  if (node1.nodeType !== node2.nodeType) return false;\n  return (\n    node1.nodeType !== node1.ELEMENT_NODE ||\n    (node1 as HTMLElement).tagName.toUpperCase() ===\n      (node2 as IRRElement).tagName\n  );\n}\n\n/**\n * To check whether two nodes are matching. If so, they are supposed to have the same serialized Id and node type. If they are both Elements, their tagNames should be the same as well. Otherwise, they are not matching.\n */\nexport function nodeMatching(\n  node1: Node,\n  node2: IRRNode,\n  domMirror: NodeMirror,\n  rrdomMirror: Mirror,\n): boolean {\n  const node1Id = domMirror.getId(node1);\n  const node2Id = rrdomMirror.getId(node2);\n  // rrdom contains elements with negative ids, we don't want to accidentally match those to a mirror mismatch (-1) id.\n  // Negative oldStartId happen when nodes are not in the mirror, but are in the DOM.\n  // eg.iframes come with a document, html, head and body nodes.\n  // thats why below we always check if an id is negative.\n  if (node1Id === -1 || node1Id !== node2Id) return false;\n  return sameNodeType(node1, node2);\n}\n","import {\n  NodeType as RRNodeType,\n  createMirror as createNodeMirror,\n} from 'rrweb-snapshot';\nimport type {\n  Mirror as NodeMirror,\n  IMirror,\n  serializedNodeWithId,\n} from 'rrweb-snapshot';\nimport type {\n  canvasMutationData,\n  canvasEventWithTime,\n  inputData,\n  scrollData,\n  styleSheetRuleData,\n  styleDeclarationData,\n} from '@rrweb/types';\nimport {\n  BaseRRNode as RRNode,\n  BaseRRCDATASectionImpl,\n  BaseRRCommentImpl,\n  BaseRRDocumentImpl,\n  BaseRRDocumentTypeImpl,\n  BaseRRElementImpl,\n  BaseRRMediaElementImpl,\n  BaseRRTextImpl,\n  IRRDocument,\n  IRRElement,\n  IRRNode,\n  NodeType,\n  IRRDocumentType,\n  IRRText,\n  IRRComment,\n} from './document';\n\nexport class RRDocument extends BaseRRDocumentImpl(RRNode) {\n  private UNSERIALIZED_STARTING_ID = -2;\n  // In the rrweb replayer, there are some unserialized nodes like the element that stores the injected style rules.\n  // These unserialized nodes may interfere the execution of the diff algorithm.\n  // The id of serialized node is larger than 0. So this value less than 0 is used as id for these unserialized nodes.\n  private _unserializedId = this.UNSERIALIZED_STARTING_ID;\n\n  /**\n   * Every time the id is used, it will minus 1 automatically to avoid collisions.\n   */\n  public get unserializedId(): number {\n    return this._unserializedId--;\n  }\n\n  public mirror: Mirror = createMirror();\n\n  public scrollData: scrollData | null = null;\n\n  constructor(mirror?: Mirror) {\n    super();\n    if (mirror) {\n      this.mirror = mirror;\n    }\n  }\n\n  createDocument(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _namespace: string | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _qualifiedName: string | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _doctype?: DocumentType | null,\n  ) {\n    return new RRDocument();\n  }\n\n  createDocumentType(\n    qualifiedName: string,\n    publicId: string,\n    systemId: string,\n  ) {\n    const documentTypeNode = new RRDocumentType(\n      qualifiedName,\n      publicId,\n      systemId,\n    );\n    documentTypeNode.ownerDocument = this;\n    return documentTypeNode;\n  }\n\n  createElement<K extends keyof HTMLElementTagNameMap>(\n    tagName: K,\n  ): RRElementType<K>;\n  createElement(tagName: string): RRElement;\n  createElement(tagName: string) {\n    const upperTagName = tagName.toUpperCase();\n    let element;\n    switch (upperTagName) {\n      case 'AUDIO':\n      case 'VIDEO':\n        element = new RRMediaElement(upperTagName);\n        break;\n      case 'IFRAME':\n        element = new RRIFrameElement(upperTagName, this.mirror);\n        break;\n      case 'CANVAS':\n        element = new RRCanvasElement(upperTagName);\n        break;\n      case 'STYLE':\n        element = new RRStyleElement(upperTagName);\n        break;\n      default:\n        element = new RRElement(upperTagName);\n        break;\n    }\n    element.ownerDocument = this;\n    return element;\n  }\n\n  createComment(data: string) {\n    const commentNode = new RRComment(data);\n    commentNode.ownerDocument = this;\n    return commentNode;\n  }\n\n  createCDATASection(data: string) {\n    const sectionNode = new RRCDATASection(data);\n    sectionNode.ownerDocument = this;\n    return sectionNode;\n  }\n\n  createTextNode(data: string) {\n    const textNode = new RRText(data);\n    textNode.ownerDocument = this;\n    return textNode;\n  }\n\n  destroyTree() {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.mirror.reset();\n  }\n\n  open() {\n    super.open();\n    this._unserializedId = this.UNSERIALIZED_STARTING_ID;\n  }\n}\n\nexport const RRDocumentType = BaseRRDocumentTypeImpl(RRNode);\n\nexport class RRElement extends BaseRRElementImpl(RRNode) {\n  inputData: inputData | null = null;\n  scrollData: scrollData | null = null;\n}\n\nexport class RRMediaElement extends BaseRRMediaElementImpl(RRElement) {}\n\nexport class RRCanvasElement extends RRElement implements IRRElement {\n  public rr_dataURL: string | null = null;\n  public canvasMutations: {\n    event: canvasEventWithTime;\n    mutation: canvasMutationData;\n  }[] = [];\n  /**\n   * This is a dummy implementation to distinguish RRCanvasElement from real HTMLCanvasElement.\n   */\n  getContext(): RenderingContext | null {\n    return null;\n  }\n}\n\nexport class RRStyleElement extends RRElement {\n  public rules: (styleSheetRuleData | styleDeclarationData)[] = [];\n}\n\nexport class RRIFrameElement extends RRElement {\n  contentDocument: RRDocument = new RRDocument();\n  constructor(upperTagName: string, mirror: Mirror) {\n    super(upperTagName);\n    this.contentDocument.mirror = mirror;\n  }\n}\n\nexport const RRText = BaseRRTextImpl(RRNode);\nexport type RRText = typeof RRText;\n\nexport const RRComment = BaseRRCommentImpl(RRNode);\nexport type RRComment = typeof RRComment;\n\nexport const RRCDATASection = BaseRRCDATASectionImpl(RRNode);\nexport type RRCDATASection = typeof RRCDATASection;\n\ninterface RRElementTagNameMap {\n  audio: RRMediaElement;\n  canvas: RRCanvasElement;\n  iframe: RRIFrameElement;\n  style: RRStyleElement;\n  video: RRMediaElement;\n}\n\ntype RRElementType<K extends keyof HTMLElementTagNameMap> =\n  K extends keyof RRElementTagNameMap ? RRElementTagNameMap[K] : RRElement;\n\nfunction getValidTagName(element: HTMLElement): string {\n  // https://github.com/rrweb-io/rrweb-snapshot/issues/56\n  if (element instanceof HTMLFormElement) {\n    return 'FORM';\n  }\n  return element.tagName.toUpperCase();\n}\n\n/**\n * Build a RRNode from a real Node.\n * @param node - the real Node\n * @param rrdom - the RRDocument\n * @param domMirror - the NodeMirror that records the real document tree\n * @returns the built RRNode\n */\nexport function buildFromNode(\n  node: Node,\n  rrdom: IRRDocument,\n  domMirror: NodeMirror,\n  parentRRNode?: IRRNode | null,\n): IRRNode | null {\n  let rrNode: IRRNode;\n\n  switch (node.nodeType) {\n    case NodeType.DOCUMENT_NODE:\n      if (parentRRNode && parentRRNode.nodeName === 'IFRAME')\n        rrNode = (parentRRNode as RRIFrameElement).contentDocument;\n      else {\n        rrNode = rrdom;\n        (rrNode as IRRDocument).compatMode = (node as Document).compatMode as\n          | 'BackCompat'\n          | 'CSS1Compat';\n      }\n      break;\n    case NodeType.DOCUMENT_TYPE_NODE: {\n      const documentType = node as DocumentType;\n      rrNode = rrdom.createDocumentType(\n        documentType.name,\n        documentType.publicId,\n        documentType.systemId,\n      );\n      break;\n    }\n    case NodeType.ELEMENT_NODE: {\n      const elementNode = node as HTMLElement;\n      const tagName = getValidTagName(elementNode);\n      rrNode = rrdom.createElement(tagName);\n      const rrElement = rrNode as IRRElement;\n      for (const { name, value } of Array.from(elementNode.attributes)) {\n        rrElement.attributes[name] = value;\n      }\n      elementNode.scrollLeft && (rrElement.scrollLeft = elementNode.scrollLeft);\n      elementNode.scrollTop && (rrElement.scrollTop = elementNode.scrollTop);\n      /**\n       * We don't have to record special values of input elements at the beginning.\n       * Because if these values are changed later, the mutation will be applied through the batched input events on its RRElement after the diff algorithm is executed.\n       */\n      break;\n    }\n    case NodeType.TEXT_NODE:\n      rrNode = rrdom.createTextNode((node as Text).textContent || '');\n      break;\n    case NodeType.CDATA_SECTION_NODE:\n      rrNode = rrdom.createCDATASection((node as CDATASection).data);\n      break;\n    case NodeType.COMMENT_NODE:\n      rrNode = rrdom.createComment((node as Comment).textContent || '');\n      break;\n    // if node is a shadow root\n    case NodeType.DOCUMENT_FRAGMENT_NODE:\n      rrNode = (parentRRNode as IRRElement).attachShadow({ mode: 'open' });\n      break;\n    default:\n      return null;\n  }\n\n  let sn: serializedNodeWithId | null = domMirror.getMeta(node);\n\n  if (rrdom instanceof RRDocument) {\n    if (!sn) {\n      sn = getDefaultSN(rrNode, rrdom.unserializedId);\n      domMirror.add(node, sn);\n    }\n    rrdom.mirror.add(rrNode, { ...sn });\n  }\n\n  return rrNode;\n}\n\n/**\n * Build a RRDocument from a real document tree.\n * @param dom - the real document tree\n * @param domMirror - the NodeMirror that records the real document tree\n * @param rrdom - the rrdom object to be constructed\n * @returns the build rrdom\n */\nexport function buildFromDom(\n  dom: Document,\n  domMirror: NodeMirror = createNodeMirror(),\n  rrdom: IRRDocument = new RRDocument(),\n) {\n  function walk(node: Node, parentRRNode: IRRNode | null) {\n    const rrNode = buildFromNode(node, rrdom, domMirror, parentRRNode);\n    if (rrNode === null) return;\n    if (\n      // if the parentRRNode isn't a RRIFrameElement\n      parentRRNode?.nodeName !== 'IFRAME' &&\n      // if node isn't a shadow root\n      node.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parentRRNode?.appendChild(rrNode);\n      rrNode.parentNode = parentRRNode;\n      rrNode.parentElement = parentRRNode as RRElement;\n    }\n\n    if (node.nodeName === 'IFRAME') {\n      const iframeDoc = (node as HTMLIFrameElement).contentDocument;\n      iframeDoc && walk(iframeDoc, rrNode);\n    } else if (\n      node.nodeType === NodeType.DOCUMENT_NODE ||\n      node.nodeType === NodeType.ELEMENT_NODE ||\n      node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      // if the node is a shadow dom\n      if (\n        node.nodeType === NodeType.ELEMENT_NODE &&\n        (node as HTMLElement).shadowRoot\n      )\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        walk((node as HTMLElement).shadowRoot!, rrNode);\n      node.childNodes.forEach((childNode) => walk(childNode, rrNode));\n    }\n  }\n  walk(dom, null);\n  return rrdom;\n}\n\nexport function createMirror(): Mirror {\n  return new Mirror();\n}\n\n// based on Mirror from rrweb-snapshots\nexport class Mirror implements IMirror<RRNode> {\n  private idNodeMap: Map<number, RRNode> = new Map();\n  private nodeMetaMap: WeakMap<RRNode, serializedNodeWithId> = new WeakMap();\n\n  getId(n: RRNode | undefined | null): number {\n    if (!n) return -1;\n\n    const id = this.getMeta(n)?.id;\n\n    // if n is not a serialized Node, use -1 as its id.\n    return id ?? -1;\n  }\n\n  getNode(id: number): RRNode | null {\n    return this.idNodeMap.get(id) || null;\n  }\n\n  getIds(): number[] {\n    return Array.from(this.idNodeMap.keys());\n  }\n\n  getMeta(n: RRNode): serializedNodeWithId | null {\n    return this.nodeMetaMap.get(n) || null;\n  }\n\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n: RRNode) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n\n    if (n.childNodes) {\n      n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id: number): boolean {\n    return this.idNodeMap.has(id);\n  }\n\n  hasNode(node: RRNode): boolean {\n    return this.nodeMetaMap.has(node);\n  }\n\n  add(n: RRNode, meta: serializedNodeWithId) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n\n  replace(id: number, n: RRNode) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n\n  reset() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n}\n\n/**\n * Get a default serializedNodeWithId value for a RRNode.\n * @param id - the serialized id to assign\n */\nexport function getDefaultSN(node: IRRNode, id: number): serializedNodeWithId {\n  switch (node.RRNodeType) {\n    case RRNodeType.Document:\n      return {\n        id,\n        type: node.RRNodeType,\n        childNodes: [],\n      };\n    case RRNodeType.DocumentType: {\n      const doctype = node as IRRDocumentType;\n      return {\n        id,\n        type: node.RRNodeType,\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId,\n      };\n    }\n    case RRNodeType.Element:\n      return {\n        id,\n        type: node.RRNodeType,\n        tagName: (node as IRRElement).tagName.toLowerCase(), // In rrweb data, all tagNames are lowercase.\n        attributes: {},\n        childNodes: [],\n      };\n    case RRNodeType.Text:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: (node as IRRText).textContent || '',\n      };\n    case RRNodeType.Comment:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: (node as IRRComment).textContent || '',\n      };\n    case RRNodeType.CDATA:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: '',\n      };\n  }\n}\n\n/**\n * Print the RRDom as a string.\n * @param rootNode - the root node of the RRDom tree\n * @param mirror - a rrweb or rrdom Mirror\n * @returns printed string\n */\nexport function printRRDom(rootNode: IRRNode, mirror: IMirror<IRRNode>) {\n  return walk(rootNode, mirror, '');\n}\nfunction walk(node: IRRNode, mirror: IMirror<IRRNode>, blankSpace: string) {\n  let printText = `${blankSpace}${mirror.getId(node)} ${node.toString()}\\n`;\n  if (node.RRNodeType === RRNodeType.Element) {\n    const element = node as IRRElement;\n    if (element.shadowRoot)\n      printText += walk(element.shadowRoot, mirror, blankSpace + '  ');\n  }\n  for (const child of node.childNodes)\n    printText += walk(child, mirror, blankSpace + '  ');\n  if (node.nodeName === 'IFRAME')\n    printText += walk(\n      (node as RRIFrameElement).contentDocument,\n      mirror,\n      blankSpace + '  ',\n    );\n  return printText;\n}\n\nexport { RRNode };\n\nexport { diff, createOrGetNode, ReplayerHandler } from './diff';\nexport * from './document';\n"],"names":["NodeType","Mirror","this","idNodeMap","Map","nodeMetaMap","WeakMap","prototype","getId","n","_a","id","getMeta","getNode","get","getIds","Array","from","keys","removeNodeFromMap","_this","childNodes","forEach","childNode","has","hasNode","node","add","meta","set","replace","oldNode","reset","toCSSText","style","properties","name","value","normalizedName","hyphenate","push","join","camelizeRE","CUSTOM_PROPERTY_REGEX","camelize","str","test","_","c","toUpperCase","hyphenateRE","toLowerCase","BaseRRNode","constructor","_args","ELEMENT_NODE","TEXT_NODE","childIterator","firstChild","nextSibling","contains","ownerDocument","parentNode","appendChild","_newChild","Error","insertBefore","_refChild","removeChild","_node","toString","BaseRRDocumentImpl","RRNodeClass","BaseRRDocument","args","super","DOCUMENT_NODE","RRNodeType","Document","textContent","documentElement","find","Element","tagName","body","head","implementation","firstElementChild","newChild","nodeType","DocumentType","some","s","child","parentElement","refChild","open","lastChild","close","write","content","publicId","doctype","createDocumentType","createDocument","_namespace","_qualifiedName","_doctype","qualifiedName","systemId","BaseRRDocumentTypeImpl","createElement","element","BaseRRElementImpl","createElementNS","_namespaceURI","createTextNode","data","text","BaseRRTextImpl","createComment","comment","BaseRRCommentImpl","createCDATASection","CDATASection","BaseRRCDATASectionImpl","DOCUMENT_TYPE_NODE","nodeName","result","classList","ClassList","attributes","class","newClassName","className","cssText","res","propertyDelimiter","split","item","tmp","length","trim","parseCSSText","setProperty","priority","removeProperty","getAttribute","setAttribute","attribute","setAttributeNS","removeAttribute","attachShadow","_init","shadowRoot","dispatchEvent","_event","attributeString","BaseRRMediaElementImpl","RRElementClass","play","paused","pause","Text","JSON","stringify","COMMENT_NODE","Comment","CDATA_SECTION_NODE","CDATA","classText","onChange","classNames","String","classes","indexOf","filter","parent","previousSibling","NAMESPACES","svg","xmlns","SVGTagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","createdNodeSet","diff","oldTree","newTree","replayer","rrnodeMirror","mirror","afterAppend","WeakSet","setTimeout","sameNodeType","calibratedOldTree","createOrGetNode","replaceChild","nodeMatching","newMeta","oldElement","newRRElement","oldContentDocument","contentDocument","mode","diffChildren","diffBeforeUpdatingChildren","scrollData","applyScroll","oldAttributes","newAttributes","newValue","sn","isSVG","image","document","src","onload","ctx","getContext","drawImage","width","height","scrollLeft","scrollTop","diffProps","inputData","applyInput","oldMediaElement","newMediaRRElement","undefined","muted","volume","currentTime","playbackRate","rrCanvasElement","rr_dataURL","canvasMutations","canvasMutation","applyCanvas","event","mutation","styleSheet","sheet","rules","applyStyleSheetMutation","delete","diffAfterUpdatingChildren","oldChildren","newChildren","oldIdToIndex","indexInOld","oldStartIndex","oldEndIndex","newStartIndex","newEndIndex","oldStartNode","oldEndNode","newStartNode","newEndNode","e","console","warn","i","oldChild","nodeToMove","newNode","referenceRRNode","referenceNode","rrNode","domMirror","nodeId","node1","node2","rrdomMirror","node1Id","node2Id","RRDocument","RRNode","unserializedId","_unserializedId","UNSERIALIZED_STARTING_ID","createMirror","documentTypeNode","RRDocumentType","upperTagName","RRMediaElement","RRIFrameElement","RRCanvasElement","RRStyleElement","RRElement","commentNode","RRComment","sectionNode","RRCDATASection","textNode","RRText","destroyTree","buildFromNode","rrdom","parentRRNode","compatMode","documentType","elementNode","HTMLFormElement","rrElement","DOCUMENT_FRAGMENT_NODE","getDefaultSN","type","walk","blankSpace","printText","dom","createNodeMirror","iframeDoc","rootNode"],"mappings":"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"}